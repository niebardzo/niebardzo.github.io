---
layout: post
title: Pentest Methodology
subtitle: Good to have it when you start
gh-repo: daattali/beautiful-jekyll
tags: [pentest, penetration tests, methodology]
comments: true
---

The methodology is based on the Web Application Hacker's Handbook 2nd Edition with some additional modification and adjustment. It is intended for grey-box testing of web application for 2 weeks engadement:

## Day 1:

### To complete:
#### I. Mapping Application
1. Explore Visible Content with passive spidering
2. Review the webroot dump for the public resources, review the docs and design diagrams.
3. Enumerate API endpoints/function for the testing
4. Test for Debug enabled. Check for debug=true, use any of the common values such as - debug,test,hide,source with the common values such as - true, yes, on 1. Use those values in parameter, header and body.
	
#### II. Anaylze the Application
1. Indetify Functionalities (in scope) 
2. Indetify Data Entry Points
3. Indetify Technologies Used.
4. Map the attack surface
  1. For each functionality identify the kinds of vulnerabilities associated with it.
  2. Create the plan of the attack with prioritization for a given time.


### Update to the team:
- Completed actions,
- Possible issues identified,
- Possible blockers,
- Plan for the attack,

## Day 2:

### To Complete
#### III. Client-Side Controls
1. Identify all hidden forms, fields, cookies, paramters. Determine the purpose and logic of the hidden value.
2. Modify the hidden values according to there purpose.
3. Attempt to decipher, deobsucate hidden values.
4. Verify that client limitations are also in place. Confirm whether application relies on client side controls for the input check.
5. If you find disabled HTML input, try to send them in the repatear.
6. If browser extenstion is required, apply additional testing for that.
7. For the identify endpoint identify if diferent HTTP methods can be used. Identify if HTTP methods can be overwritten.

#### IV. Test Authentication Mechanism
1. Locate all authenticaiton related mechanisms (login, registration, recovery)
2. Test password quality (rules of the password, test if the password validation is complete). Determine the probability of success in the brute-force attacks.
3. Test for Username Enumeration. Where the application expects the username, submit one valid and one invalid and observe the differences.
4. Check for account lock-down policy
5. Test account recovery function. Check how it works, if there is challenge as a secret question, harvest the list of questions and check for predictable answers. If it involves sending email, check it is possible to control any of the parameter (SMTP part, URL parameters)
6. Test remember me function. Inspect all persistent cookie - try tamper the cookie, compare the results of remembering several accounts.
7. Test any impersonation function. Try to use the functionality for privilage escalation.
8. Test username uniqueness. It may allow to enumerate valid usernames. If the collision are allowed, try to hijack other userl's account.
9. Test the credetial transmission (non-TLS, URL parameters, leakage by the Referer, if the credentials are stored in cookies)
10. Check for credentials distrubition ( if confirm URL must be clicked, register few accounts and check if the token is predictable) 
11. Test for fail-open when it is possible to edit password and login.
12. If multistage mechanism in place, test it, proceed with all stages in a different seqquence. Proceed directly to each stage and then continue the normal flow. Try skipping some stages. Think for further cases to push the staging to its limits.
13. For multistaging, check if the paramter is submitted in different stages. Example username. Try to modify it, if that is possible to authorize as other user.	
14. For multistaging, if the application requires the challenge on any stage test the two common defects:
- If the challenge is send with the user's response with the same request try to set your own challenge.
- Try submitting again the request generting the challenge, if it vary with every reponse you can set your own challenge by repeatingly request the challenge.

#### V. Session Management Mechanism
1. Analyze the mechanism used for session management, identify the item used to represent user's session. Check if the whole token is validated by modifing the single bytes.
2. Analyze the token itself, entropy, correlation with username, different encoding. 
3. Check if the token appears to be CBC encrypted - use Bit Flip Burp Intruder
4. Check for insecure transmission of the token - cookie without secure flag, non-TLS, URL param
5. Login and logout several times to determine if the session token is dynamic
6. If the JWT is used, try JWT vulns.
7. If the cookie consist any user part, try tampering it.
8. Check if the application support concurrent session by login in two different webbrowsers
9. Check the session expiration ( Burp Intruder increment the time)
10. Check if the logout function is effective. Attempt to reuse the old token. 
11. Check for session fixation. If the new token is generated after login or is it reused.
12. Check for CSRF - missing anti-CSRF, also if exploit possible through simple HTTP request.
13. Check cookie scope'ing - if parent domain is specified for authentication cookie. 

### Update to the team:
- Tests performed,
- Findings,
- Blockers 

## Day 3-4:

### To complete:
#### VI. Access Control Testing:
1. Build understanding of the possible horizontal and vertical priv escalation.
2. If there are vertical priv escalation possible, identified endpoints/functionalites accessible only to those privilaged account. The use less privilaged account to try to access those resources.
3. For each user privilege, review resources available to a user. Attempt to access those resources from an unauthorized user account by replaying the request using the unauthorized user’s session token. 
4. Check if user with the same privilage can access or modify the data belonging to other user's with the same privilages.
5. In multistage functionalities, check if other stages of the functionality correctly implements the access control.
6. Test for insecure access control methods:
- Look for parameters such as edit=false or access=read in any key requests, and modify these in line with their apparent role to try to interfere with the application’s access control logic.
- Check if the Referer or Origin header is used for access control.
- In case some specific HTTP methods are blocked for specific role for URL try the - X-Original-URL or different method of URL rewrite. Try the HEAD HTTP method if it is allowed by webserver. 
7. Check for IDOR - Insecure direct object reference

### Update to the team:
- Tests performed,
- Findings,
- Blockers

## Day 5-6:

### To complete:
#### VII. Input-Based Vulns
1. If possible try to fuzz all parameters for:
  1.1 SQLi
  1.2 XSS and Other Response Injection (XSS Reflected/Stored, Header Injection, Open Redirection)
  1.3 Command Injection
  1.4 Path Traversal
  1.5 Script Injection
  1.6 File Inclusion
  1.7 Template Injection
  1.8 SSRF
1a. Use the Grep Burp function to look for specfic values in the reponse or second order page.
1c. Exploit the vulnerability for proofs.
2. If fuzzing is not possible e.g. the application has the flow that cannot be abused.
2a. Identify the parameters/functionalities that may be specific to the vulnerability e.g. parameter "path" should be tested for File inclusion, SSRF, Path traversal.
2b. Once identify try the payloads specific to the "possible vulnerabilities" for the functionality.
2c. Exploit the vulnerability.

#### VIII. Test for Function-Specific Input Vulnerabilities
1. Depending on the application mapping there are specific vulnerabilities that may exist in the web application.
2. Test for those vulnerabilities:
  2.1 SMTP Injection
  2.2 Overflows and format string (for custom C/C++ websevers)
  2.3 SOAP Injection
  2.4 LDAP Injection
  2.5 XPath Injection
  2.6 SSRF
  2.7 XXE

### Update to the team:
- Tests performed,
- Findings,
- Blockers

## Day 7-8:

### To complete:
#### IX. Logic Flaws
1. Identify the following features in the web application:
  1.1 Multistage process,
  1.2 Critical Security Functions e.g. login, password reset,
  1.3 Trust Boundaries ( from anonymous to self-registered to logged in)
  1.4 Context-based functionality e.g. withdrawing money
  1.5 Adjustment to fees, quantities etc.
2. Multistage process:
  2.1 Attempt to submit request out of sequence. Try skip some stages.
  2.2 Try to take parameters from previous stage and send them in next stage to interfere with the process and maybe modify some values.
  2.3 If the process involves different user to submit something, try to submit the request as current user.
  2.4 Try to determine the assuptions made by the developers in context based function, try to abuse those,
3. Test Handling Incomplete Input.
  3.1 For crticial functions, test the application resilience on the incomplete request e.g. remove the paremeter or value.
4. Trust Boundires:
  4.1 Check specific cases that would normally not occur when trust boundries are changed: e.g. when performing the password reset, do not complete it but move directly to auth user context.
  4.2 Try to determine if you could harness directly or indirectly higher privilage function
5. Transaction Logic:
  5.1 Test negative values in the transaction, check how application reacts.
  5.2 Identify if the any fees can be manipulated by the user.

### Update to the team:
- Tests performed,
- Findings,
- Blockers

## Day 9:

### To complete:
#### X. Misc Testing
1. Find Vulnerable Components e.g. Burp Vulnerability Scanner.
2. Examine Webserver Config e.g. Weak Tomcat creds.
3. Examine Default Content on the webserver e.g. phpinfo
4. Check for CORS Misconfiguration.
5. Test TLS Config.
6. If you have time, analyze statically JS files for DOM-based attacks.
  6.1 Identify all uses of the following APIS, which can be used to access DOM data via crafted URL: document.location, document.URL, document.URLUnencoded, document.referrer, window.location
  6.2 Check if the data from the user is passed to one of the following functions for DOM XSS: document.write(), document.wirteln(), eval(), window.execScript(), window.setInterval(), window.setTimeout()
  6.3 Check if the user data is passed to one of the following functions for redirections: document.location, document.URL, document.open(), window.location.href, window.navigate(), window.open()

### Update to the team:
- Tests performed,
- Findings,
- Blockers

## Day 10:
### To complete:
1. Reporting
2. Final call with the development Team.
